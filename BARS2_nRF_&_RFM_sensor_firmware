// Firmware per Hooly vers. 2: gestisce RFM69HW e sensore SHT31 con ATmega328
// semplificato
// Testato

#include <LowPower.h>
#include "Adafruit_SHT31.h"
#include <EEPROM.h>
#include <RFM69.h>
#include <RF24.h>
#include <OneWire.h>
#include <DallasTemperature.h>

#define LED_PIN       3   // Digital pin for led connection
#define TEMP_PIN     A3   // Digital pin for ds18b20 sensor
#define SWITCH1       8   // Digital pin for sw1(SJ1) - transceiver definition close=0=RFM69 open=1=NFR24L01
#define BATTERY_PIN  A2   // Analog pin for battery voltage measure

#define NETWORKID     0   // Must be the same for all nodes - DO NOT CHANGE
#define MYNODEID      2   // Trasmitter node ID - DO NOT CHANGE
#define TONODEID      1   // Destination node ID - DO NOT CHANGE
#define FREQUENCY     RF69_433MHZ //  - DO NOT CHANGE

#define DEBUG         1   // debug mode print useful info on serial; set 0 in normal mode otherwise memory problems

Adafruit_SHT31 sht31 = Adafruit_SHT31();

OneWire oneWire(TEMP_PIN);
DallasTemperature ds18b20(&oneWire);

RFM69 radioRFM;
RF24 radioNRF(2,10);

// Global variables
char nodeID[5] = "5556";
int period = 300;
int counter = 0;
int sensor_type;
int min_vcc = 575;
bool IS_RFM69HW;
bool IS_NRF24L01;

// -------------------------
// Start setup

void setup() {

  // inizializzazioni
  Serial.begin(115200);
  pinMode(LED_PIN, OUTPUT);
  pinMode(SWITCH1, INPUT_PULLUP);
  bool radiotype;

  // definisce il tipo di transceiver
  // da verificare e togliere i DEBUG <---------------------------------
  radiotype=digitalRead(SWITCH1);
  if (radiotype) {
    IS_NRF24L01 = 1; IS_RFM69HW = 0;
    if(DEBUG) { Serial.println("done -> NRF24L01");}
  }
  else {
    IS_NRF24L01 = 0; IS_RFM69HW = 1;
    if(DEBUG) { Serial.println("done -> RFM69HW");}
  }

  // Definisce il tipo di sensore
  sht31.begin(0x44);
  if(sht31.readStatus() == 32784) {
    sensor_type = 1;
  }
  ds18b20.begin();
  if(ds18b20.getDeviceCount()) {
    sensor_type = 2 ;
  }

  // Inizializza il transceiver
  if (IS_RFM69HW) {
    radioRFM.initialize(FREQUENCY, MYNODEID, NETWORKID);
    radioRFM.setHighPower();
  }
  if (IS_NRF24L01) {
    radioNRF.begin();
    radioNRF.setPALevel(RF24_PA_MAX);
    radioNRF.setChannel(0x4c);
    radioNRF.setDataRate(RF24_250KBPS);
    radioNRF.setAutoAck(0);
    radioNRF.setRetries(1,10);
    radioNRF.openWritingPipe(0xF0F0F0F0E1LL);
    radioNRF.enableDynamicPayloads();
    radioNRF.powerUp();
  }

  led_blink(5,250);
}

// End setup
// ------------------------------------------------------------------
// Start loop

void loop() {

  int temp;
  int hum;
  int vcc;
  char outBuffer[32] = "";

  // legge la temperatura
  if (sensor_type == 1 ) {
    temp = sht31.readTemperature() * 100;
    hum = sht31.readHumidity() * 100;
  }
  if (sensor_type == 2 ) {
    ds18b20.requestTemperatures();
    delay(1000);
    temp = (ds18b20.getTempCByIndex(0)*100);
    hum = 0;
  }

  // legge il livello di batteria
  vcc = analogRead(BATTERY_PIN);

  // Prepare OutBuffer

  int c;
  int x;
  int i;

  outBuffer[0] = nodeID[0];
  outBuffer[1] = nodeID[1];
  outBuffer[2] = nodeID[2];
  outBuffer[3] = nodeID[3];
  outBuffer[4] = ':';
  c = counter;
  for (i = 8; i >= 5; --i) {x = c %10; outBuffer[i] = '0' + x ; c = (c - x) / 10;}
  outBuffer[9] = ':';
  c = temp;
  if (temp < 0) { outBuffer[10] = '-'; c = c * -1;} else { outBuffer[10] = '+';}
  for (i = 14; i >= 11; --i) {x = c %10; outBuffer[i] = '0' + x ; c = (c - x) / 10;}
  outBuffer[15] = ':';
  c = hum;
  for (i = 19; i >= 16; --i) {x = c %10; outBuffer[i] = '0' + x ; c = (c - x) / 10;}
  outBuffer[20] = ':';
  c = vcc;
  for (i = 24; i >= 21; --i) {x = c %10; outBuffer[i] = '0' + x ; c = (c - x) / 10;}
  outBuffer[25] = ':';
  c = period;
  for (i = 29; i >= 26; --i) {x = c %10; outBuffer[i] = '0' + x ; c = (c - x) / 10;}
  outBuffer[30] = ':';
  outBuffer[31] = 0;

  digitalWrite(LED_PIN, HIGH);

  if (IS_RFM69HW) {
    radioRFM.send(TONODEID, outBuffer, 32);
  }
  if (IS_NRF24L01) {
    radioNRF.write(outBuffer, 32);
  }

  digitalWrite(LED_PIN, LOW);

  if(counter == 9999) counter = 0; else counter ++;
  delay(1000);

  delay(10);

  if (IS_RFM69HW) radioRFM.sleep();
  if (IS_NRF24L01) radioNRF.powerDown();

  gotosleep(period);

}

// End loop
// ------------------------------------------------------------------
// Start function gotosleep
//
// sleep for low consumption (6uA) between transmissions

void gotosleep(int period) {
  int timer = period;
  while (timer > 0) {
    if (timer > 8) { LowPower.powerDown(SLEEP_8S, ADC_OFF, BOD_OFF); timer = timer -8; }
    else { LowPower.powerDown(SLEEP_1S, ADC_OFF, BOD_OFF); timer = timer -1; }
  }
}

// End function gotosleep
// -------------------------
// Start function led_blink
//
// led blinks n times for speed:
// 50 = very fast - 250 = readable - 500 = slow

void led_blink(int times, int speed) {
  for (int i = 0; i < times; i++) {
    digitalWrite(LED_PIN, HIGH);      // turn LED on
    delay(speed);
    digitalWrite(LED_PIN, LOW);       // turn LED off
    delay(speed);
  }
}

// End function led_blink
// -------------------------
