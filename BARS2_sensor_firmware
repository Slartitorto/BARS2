// Firmware per Hooly vers. 2: gestisce RFM69HW e sensore SHT31 con ATmega328
//

#include <LowPower.h>
#include "Adafruit_SHT31.h"
#include <SPI.h>
#include <EEPROM.h>
#include <RFM69.h>

#define ledPin 3
#define batteryPin A1 // Analog pin for battery voltage measure

#define ECP 1          // EEPROM register where store info for pause between trasmission
#define NETWORKID     0   // Must be the same for all nodes
#define MYNODEID      2   // Trasmitter node ID
#define TONODEID      1   // Destination node ID
#define FREQUENCY   RF69_433MHZ
#define DEBUG         1


Adafruit_SHT31 sht31 = Adafruit_SHT31();
RFM69 radio;

// Global variables
int counter = 0;
int nodeID = 5555;
int code_period;
int period;
char outBuffer[32] = "";
byte outBufferLen;
int min_vcc = 400; // 555 is default


// -------------------------
// Start setup

void setup() {
  pinMode(ledPin, OUTPUT);

  Serial.begin(115200);

  sht31.begin(0x44);

  radio.initialize(FREQUENCY, MYNODEID, NETWORKID);
  radio.setHighPower();

  code_period_setup(nodeID);
  period = get_period(code_period);
}
// End setup
// -------------------------
// Start loop

void loop() {
  delay(10);

  long start_timer=millis();
  int temp = sht31.readTemperature() * 100;
  int hum = sht31.readHumidity() * 100;
  int vcc = analogRead(batteryPin);

  brown_out_detector(vcc,nodeID);

  sprintf(outBuffer, "%04d:%06d:%04d:%04d:%04d:%04d",nodeID,counter,temp,hum,vcc,period);
  outBufferLen = strlen(outBuffer);

  if(DEBUG) {  Serial.print("Vcc = "); Serial.println(vcc); }
  if(DEBUG) {  Serial.print("Temp *C = "); Serial.println(temp); }
  if(DEBUG) {  Serial.print("Hum. % = "); Serial.println(hum); }
  if(DEBUG) {  Serial.print("Measurament time = "); Serial.println((millis() - start_timer)); }
  start_timer = millis();
  if(DEBUG) {  Serial.print("Counter = "); Serial.println(counter); }
  if(DEBUG) {  Serial.println(outBuffer); }

  digitalWrite(ledPin, HIGH);
  if(DEBUG) {  Serial.println("Sending data"); }
  radio.send(TONODEID, outBuffer, outBufferLen);
  delay(10);
  digitalWrite(ledPin, LOW);
  if(DEBUG) {  Serial.print("Trasmission time = "); Serial.println((millis() - start_timer)); }
  if(DEBUG) {  Serial.println(); }

  if(counter == 999999) counter = 0; else counter ++;
  delay(10);
  radio.sleep();

  gotosleep(period);
  delay(10);
}

// End loop
// -------------------------
// Start function gotosleep

void gotosleep(int period) {
  int timer = period;
  if(DEBUG) { timer = 5; }
  while (timer > 0) {
    if (timer > 8) { LowPower.powerDown(SLEEP_8S, ADC_OFF, BOD_OFF); timer = timer -8; }
    else { LowPower.powerDown(SLEEP_1S, ADC_OFF, BOD_OFF); timer = timer -1; }
  }
}

// End function gotosleep
// -------------------------
// Start function code_period_setup

void code_period_setup(char nodeID[5]) {
  // at boot, get period from server or EEPROM

  delay(500);
  unsigned long started_waiting_at = millis();
  int timeout = 0;
  if(DEBUG) {  Serial.println("entering in code_period_setup ... reading EEPROM"); }

  // Check stored value if set; otherwise set 5 as default
  code_period = EEPROM.read(ECP);
  if (code_period < 1 || code_period > 9) {
    if(DEBUG) {  Serial.println("code_period <1 or >9"); }
    code_period = 5;                 // maybe EEPROM not yet set; set code_period = 5 as default value = 60 sec.
    EEPROM.write(ECP,code_period);   // set EEPROM as default value = 5
    led_blink(code_period,200);      // speedly blink code_period times
    if(DEBUG) {  Serial.println("EEPROM not set: setting code_period = 5 (60 sec.)"); }
  } else {
    if(DEBUG) {  Serial.println("code_period between 1 and 9"); }
    if(DEBUG) {  Serial.print("Setting code_period = "); }
    if(DEBUG) {  Serial.print(code_period); }
    if(DEBUG) {  Serial.println(" as stored value"); }
    led_blink(code_period,200);      // speedly blink code_period times
  }

  // Get code_period from server
  if(DEBUG) {  Serial.println("Sending 000000 to server"); }
  sprintf(outBuffer, "%04d:000000:0000:0000:0000:0000",nodeID);
  outBufferLen = strlen(outBuffer);
  radio.send(TONODEID, outBuffer, outBufferLen);

  while ( ! radio.receiveDone()) {
    if (millis() - started_waiting_at > 10000 ){            // If waited longer than 10s, indicate timeout and exit while loop
      timeout = 1;
      break;
    }
  }
  if ( timeout ) {
    if(DEBUG) {  Serial.println("Failed to get code_period from server: timeout; using stored value"); }
    delay (5);
  } else {
    if(DEBUG) { Serial.print("Got data from server = "); }
    if(DEBUG) {  Serial.print((char)radio.DATA);  }
    // da verificare se questa sopra non funziona; in tal caso usare queste sotto
    //  for (byte i = 0; i < radio.DATALEN; i++)
    //  {
    //    if(DEBUG) {  Serial.print((char)radio.DATA[i]);  }
    //  }
    char nodeID_received[5] = "";
    nodeID_received[0] = radio.DATA[0];
    nodeID_received[1] = radio.DATA[1];
    nodeID_received[2] = radio.DATA[2];
    nodeID_received[3] = radio.DATA[3];
    if (atoi(nodeID_received) == nodeID) {
      if(DEBUG) {  Serial.println("Got code_period from server: using that value"); }
    code_period = (radio.DATA[5] -48) ;
    EEPROM.write(ECP,code_period);
    delay (5);
  } else {
    if(DEBUG) {  Serial.println("Failed, response not good; using stored value"); }
    delay (5);
  }
}
code_period = EEPROM.read(ECP);
led_blink(code_period,500);        // slowly blink code_period times
}

// End function code_period_setup
// -------------------------
// Start function get_period

int get_period(int code_period) {
  int period;
  if (code_period == 1)
  period = 5;
  else if (code_period == 2)
  period = 15;
  else if (code_period == 3)
  period = 30;
  else if (code_period == 4)
  period = 60;
  else if (code_period == 5)
  period = 180;
  else if (code_period == 6)
  period = 300;
  else if (code_period == 7)
  period = 900;
  else if (code_period == 8)
  period = 1800;
  else if (code_period == 9)
  period = 3600;
  return period;
}

// End function get_period
// -------------------------
// Start function led_blink

void led_blink(int times, int speed) {
  // 50 = very fast - 250 = readable - 500 = slow
  for (int i = 0; i < times; i++) {
    digitalWrite(ledPin, HIGH);      // turn LED on
    delay(speed);
    digitalWrite(ledPin, LOW);       // turn LED off
    delay(speed);
  }
}

// End function led_blink
// -------------------------
// Start function Brown-Out Detector

void brown_out_detector(int vcc, char nodeID) {
  if (vcc <= min_vcc) {
    delay(100);     // double check for safe power down
    if (analogRead(batteryPin) <= min_vcc) {
      if(DEBUG) {  Serial.print("Failed, got vcc not enough; power down to save battery: "); }
      if(DEBUG) {  Serial.println(vcc); }
      sprintf(outBuffer, "%04d:000000:0000:0000:0000:0000",nodeID);
      outBufferLen = strlen(outBuffer);
      radio.send(TONODEID, outBuffer, outBufferLen);
      LowPower.powerDown(SLEEP_FOREVER, ADC_OFF, BOD_OFF);
    }
  }
}

// End function Brown Out Detector
// -------------------------
