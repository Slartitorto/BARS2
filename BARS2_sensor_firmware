// Firmware per Hooly vers. 2: gestisce RFM69HW e sensore SHT31 con ATmega328
//

#include <LowPower.h>
#include "Adafruit_SHT31.h"
#include <EEPROM.h>
#include <RFM69.h>

#define ledPin        3   // Digital pin for led connection
#define batteryPin   A1   // Analog pin for battery voltage measure

#define ECP           1   // EEPROM address where store info for pause between transmission
#define EFORGEDADD    3   // EEPROM address where store flag (2 char) forged (= 234 and 189)
#define ENODEIDADD    6   // EEprom address where store nodeID (5 char)
#define NODEIDLEN     4   // number of digit for nodeID
#define KEY1        234   // ranom key
#define KEY2        189   // ranom key
#define NETWORKID     0   // Must be the same for all nodes
#define MYNODEID      2   // Trasmitter node ID
#define TONODEID      1   // Destination node ID
#define FREQUENCY     RF69_433MHZ

#define DEBUG         1   // debug mode print useful info on serial; set 0 in not debug

Adafruit_SHT31 sht31 = Adafruit_SHT31();
RFM69 radio;

// Global variables
long counter = 0;
int nodeID = 5556;
int code_period;
int period;
char outBuffer[32] = "";
byte outBufferLen;
int min_vcc = 575;

// -------------------------
// Start setup

void setup() {

  if(DEBUG) {  min_vcc = 200; }

  pinMode(ledPin, OUTPUT);

  Serial.begin(115200);

  sht31.begin(0x44);

  radio.initialize(FREQUENCY, MYNODEID, NETWORKID);
  radio.setHighPower();

  // set_nodeID();   // to be verified

  code_period_setup(nodeID);
  period = get_period(code_period);
}
// End setup
// -------------------------
// Start loop

void loop() {
  delay(10);

  long start_timer=millis();
  int temp = sht31.readTemperature() * 100;
  int hum = sht31.readHumidity() * 100;
  int vcc = analogRead(batteryPin);

  brown_out_detector(vcc,nodeID);

  int a = nodeID;
  int b = counter;
  int c = temp;
  int d = hum;
  int e = vcc;
  int f = period;

  sprintf(outBuffer, "%04d:%06d:%04d:%04d:%04d:%04d",a,b,c,d,e,f);
  // sprintf(outBuffer, "%04d:%06d:%04d:%04d:%04d:%04d",nodeID,counter,temp,hum,vcc,period);
  outBufferLen = strlen(outBuffer);

  if(DEBUG) {  Serial.print("Vcc = "); Serial.println(vcc); }
  if(DEBUG) {  Serial.print("Temp *C = "); Serial.println(temp); }
  if(DEBUG) {  Serial.print("Hum. % = "); Serial.println(hum); }
  if(DEBUG) {  Serial.print("Measurament time = "); Serial.println((millis() - start_timer)); }
  start_timer = millis();
  if(DEBUG) {  Serial.print("Counter = "); Serial.println(counter); }
  if(DEBUG) {  Serial.println(outBuffer); }

  digitalWrite(ledPin, HIGH);
  if(DEBUG) {  Serial.println("Sending data"); }
  radio.send(TONODEID, outBuffer, outBufferLen);
  delay(10);
  digitalWrite(ledPin, LOW);
  if(DEBUG) {  Serial.print("Trasmission time = "); Serial.println((millis() - start_timer)); }
  if(DEBUG) {  Serial.println(); }

  if(counter == 999999) counter = 0; else counter ++;
  delay(10);
  radio.sleep();

  gotosleep(period);
  delay(10);
}

// End loop
// -------------------------
// Start function gotosleep

void gotosleep(int period) {
  int timer = period;
  if(DEBUG) { timer = 5; }
  while (timer > 0) {
    if (timer > 8) { LowPower.powerDown(SLEEP_8S, ADC_OFF, BOD_OFF); timer = timer -8; }
    else { LowPower.powerDown(SLEEP_1S, ADC_OFF, BOD_OFF); timer = timer -1; }
  }
}

// End function gotosleep
// -------------------------
// Start function code_period_setup

void code_period_setup(int nodeID) {
  // at boot, get period from server or EEPROM

  delay(500);
  unsigned long started_waiting_at = millis();
  int timeout = 0;
  if(DEBUG) {  Serial.println("entering in code_period_setup ... reading EEPROM"); }

  // Check stored value if set; otherwise set 5 as default
  code_period = EEPROM.read(ECP);
  if(DEBUG) {  Serial.print("code_period = "); Serial.println(code_period); }
  if (code_period < 1 || code_period > 9) {
    if(DEBUG) {  Serial.println("code_period <1 or >9"); }
    code_period = 5;                 // maybe EEPROM not yet set; set code_period = 5 as default value = 60 sec.
    EEPROM.write(ECP,code_period);   // set EEPROM as default value = 5
    led_blink(code_period,200);      // speedly blink code_period times
    if(DEBUG) {  Serial.println("EEPROM not set: setting code_period = 5 (60 sec.)"); }
  } else {
    if(DEBUG) {  Serial.println("code_period between 1 and 9"); }
    if(DEBUG) {  Serial.print("Setting code_period = "); }
    if(DEBUG) {  Serial.print(code_period); }
    if(DEBUG) {  Serial.println(" as stored value"); }
    led_blink(code_period,200);      // speedly blink code_period times
  }

  // Get code_period from server
  if(DEBUG) {  Serial.print("Sending get_code_period to server from nodeID "); Serial.println(nodeID); }
  sprintf(outBuffer, "%04d:get_code_period",nodeID);
  outBufferLen = strlen(outBuffer);
  radio.send(TONODEID, outBuffer, outBufferLen);

  while ( ! radio.receiveDone()) {
    if (millis() - started_waiting_at > 10000 ){            // If waited longer than 10s, indicate timeout and exit while loop
      timeout = 1;
      break;
    }
  }
  if ( timeout ) {
    if(DEBUG) {  Serial.println("Failed to get code_period from server: timeout; using stored value"); }
    delay (5);
  } else {

    if(DEBUG) { Serial.print("Got data from server = "); }
    if(DEBUG) { for (byte i = 0; i < radio.DATALEN; i++) Serial.print((char)radio.DATA[i]); Serial.println(); }

    char nodeID_received[5] = "";
    nodeID_received[0] = radio.DATA[0];
    nodeID_received[1] = radio.DATA[1];
    nodeID_received[2] = radio.DATA[2];
    nodeID_received[3] = radio.DATA[3];

    if(DEBUG) { Serial.print("nodeID_received = "); Serial.println(nodeID_received); }
    if(DEBUG) { Serial.print("my_nodeID = "); Serial.println(nodeID); }

    int code_period_received = radio.DATA[5] - 48 ;

    if(DEBUG) { Serial.print("code_period_received = "); Serial.println(code_period_received); }

    if ((atoi(nodeID_received) == nodeID) && (code_period_received > 0) && (code_period_received < 9)) {
      if(DEBUG) {  Serial.println("Got code_period from server: using that value"); }

      EEPROM.write(ECP,code_period_received);
      delay (5);
    } else {
      if(DEBUG) {  Serial.println("Failed, response not good; using stored value"); }
      delay (5);
    }
  }
  code_period = EEPROM.read(ECP);
  led_blink(code_period,500);        // slowly blink code_period times
}

// End function code_period_setup
// -------------------------
// Start function get_period

int get_period(int code_period) {
  int period;
  if (code_period == 1)
  period = 5;
  else if (code_period == 2)
  period = 15;
  else if (code_period == 3)
  period = 30;
  else if (code_period == 4)
  period = 60;
  else if (code_period == 5)
  period = 180;
  else if (code_period == 6)
  period = 300;
  else if (code_period == 7)
  period = 900;
  else if (code_period == 8)
  period = 1800;
  else if (code_period == 9)
  period = 3600;
  return period;
}

// End function get_period
// -------------------------
// Start function led_blink

void led_blink(int times, int speed) {
  // 50 = very fast - 250 = readable - 500 = slow
  for (int i = 0; i < times; i++) {
    digitalWrite(ledPin, HIGH);      // turn LED on
    delay(speed);
    digitalWrite(ledPin, LOW);       // turn LED off
    delay(speed);
  }
}

// End function led_blink
// -------------------------
// Start function Brown-Out Detector

void brown_out_detector(int vcc, char nodeID) {
  if (vcc <= min_vcc) {
    delay(100);     // double check for safe power down
    if (analogRead(batteryPin) <= min_vcc) {
      if(DEBUG) {  Serial.print("Failed, got vcc not enough; power down to save battery: "); }
      if(DEBUG) {  Serial.println(vcc); }
      sprintf(outBuffer, "%04d:000000:0000:0000:0000:0000",nodeID);
      outBufferLen = strlen(outBuffer);
      radio.send(TONODEID, outBuffer, outBufferLen);
      LowPower.powerDown(SLEEP_FOREVER, ADC_OFF, BOD_OFF);
    }
  }
}

// End function Brown Out Detector
// -------------------------
// Start function set_nodeID
// to be verified

void set_nodeID() {
  // check if Hooly is new
  int test1 = EEPROM.read(EFORGEDADD);
  int test2 = EEPROM.read(EFORGEDADD+1);
  if (test1 != KEY1 || test2 != KEY2) {  // Hooly is new
    // await nodeID from server
    if (radio.receiveDone()) // Got one!
    {
      // Print out the information:
      if(DEBUG) {  Serial.print("received  "); }
      if(DEBUG) {  Serial.println((char)radio.DATA); }
      if(DEBUG) {  for (byte i = 0; i < radio.DATALEN; i++) Serial.print((char)radio.DATA[i]); }
      if(atoi(radio.DATA[1]) == KEY1) { // da sistemare

        // write nodeID into ENODEIDADD
        for (int i = 0; i < NODEIDLEN; i++) {
          EEPROM.write(ENODEIDADD+i,0);
          EEPROM.write(ENODEIDADD+i,radio.DATA[i]);
        }
        // write the Hooly is not new and it is forged
        EEPROM.write(EFORGEDADD,0);
        EEPROM.write(EFORGEDADD+1,0);
        EEPROM.write(EFORGEDADD,KEY1);
        EEPROM.write(EFORGEDADD+1,KEY2);
      }
    }
  }
  // set nodeID from EEPROM ENODEIDADD
  nodeID = 0;
  for (int i = NODEIDLEN; i = 0 ; i--) {
    int x =  EEPROM.read(ENODEIDADD+i);
    nodeID = nodeID + (x * 10 ^ i);
  }
}

// End function set_nodeID
// -------------------------
