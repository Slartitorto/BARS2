
// Rev 0.4

// --- rispetto al 0.3b
// sostituito il transceiver da nRF24L01 a RFM69HW
// Compila, da provare

// --- rispetto al 0.3a
// contiene l'invio ogni minuto di un keep_alive; il keep alive avviene anche quando
// manda il dato (se ne occupa datasink.php)

// ---  rispetto al 0.3

// Alla prima accensione registra in Eprom il router name e la key, entrambi presi dal
// server su db; in questo modo non ho da personalizzare il codice per ogni installazione
// necessita della tabella new_routers popolata

// ---  rispetto al 0.2c

// versione senza pulsante: se riceve un count = 0000 fa una get per ottenere
// il period di quel serial e lo ritrasmette al sensore che sta in attesa 10 sec.
// Attenzione: deve cambiare il firmware, il DB, device_settings e get_period

// ---  rispetto al 0.2b (che funziona) cambio metodo: AP con captive portal solo on demand

// all'accensione prova a connettersi e se non si connette lampeggia e riprova
// finchè non si connette oppure finchè non si preme il tasto e solo allora va
// in APmode.
// Anche nel ciclo loop() se premi il tasto va in APmode con captive portal.
// Attenzione che quando premi il tasto, resetta le credenziali in eprom; quindi
// se lo spegni mentre sta in APmode, quando lo
// riaccendi non riuscirà a connettersi e lampeggia veloce all'infinito finchè
// non premi il tasto.
// Se sbagli le credenziali, non esce dalla modalità AP finchè non le metti
// giuste; nel frattempo il led resta acceso.


// ------ README -------
// led lampeggiante veloce -> sta provando a connettersi alla rete
// led fisso -> sta in APmode con captive portal attivo
// led lampeggiante lento -> errore nella connessione http verso il server (80 sec., poi riprova)
// lampo led -> ricezione dei dati ed invio al server

// * nRF24L01+  ESP8266  RFM69HW
// * VCC        VCC       VCC
// * CE         GPIO5*    DIO0
// * CSN/CS     GPIO15**  NSS
// * SCK        GPIO14    SCK
// * MISO       GPIO12    MISO
// * MOSI       GPIO13    MOSI
// * GND        GND       GND

// * attenzione alla libreria, mettere in RFM69.h:
// #define RF69_IRQ_PIN          5
// #define RF69_IRQ_NUM          5
// ** usare radio.setCS(15); nello sketch

// vedi http://thebillplease.net/play/esp8266-with-rfm69-using-lowpowerlab/


// usare NODE MCU (ESP-12E) come tipo di arduino
// oppure "Generic ESP8266 Module"

#include <ESP8266WiFi.h>          //https://github.com/esp8266/Arduino
#include <DNSServer.h>
#include <ESP8266WebServer.h>
#include <WiFiManager.h>
#include <WiFiClient.h>
#include <EEPROM.h>

#include <RFM69.h>
#include <SPI.h>
#define NETWORKID     0   // Must be the same for all nodes
#define MYNODEID      1   // My node ID
#define TONODEID      2   // Destination node ID
#define FREQUENCY   RF69_433MHZ

#define LED 4
#define BUTTON 16

// Remote site information
const char http_site[] = "myhooly.hooly.eu";
const int http_port = 80;

// global variables
char router_name[7];
unsigned long keep_alive_timeout = millis();

// Initialize RFM69 library
RFM69 radio;

// --------------------------------
// setup routine, run once
void setup() {

  // Open a serial port so we can send keystrokes to the module:
  Serial.begin(115200);
  Serial.print("Node ");
  Serial.print(MYNODEID,DEC);
  Serial.println(" ready");

  pinMode(LED, OUTPUT);
  pinMode(BUTTON, INPUT_PULLUP);

  WiFi.begin();
  while (WiFi.status() != WL_CONNECTED)
  {
    delay(500);
    led_blink();
    if (digitalRead(BUTTON) == LOW) {
      captive_portal();
    }
  }

  WiFiClient client;

  EEPROM.begin(64);
  if (check_eeprom_new()) {

    // --- case eeprom new
    client.connect(http_site, http_port);
    client.print("GET /service_door.php?service=get_new_router");
    client.println(" HTTP/1.1");
    client.print("Host: ");
    client.println(http_site);
    client.println("Connection: close");
    client.println();

    // timeout
    unsigned long timeout = millis();
    while (client.available() == 0) {
      if (millis() - timeout > 5000) {
        client.stop();
        return;
      }
    }

    // Read the line of the reply from server and put it in the int array
    int router_name_and_key[40];
    while(client.available()) {
      String line = client.readStringUntil('\r');
      for (int i=1;i<40;i++){
        router_name_and_key[i]=line.charAt(i);
      }
    }

    // eeprom clearing
    for (int i = 1; i < 40; i++) {
      EEPROM.write(i,0);
    }
    EEPROM.commit();

    // eeprom write router_name ":" key
    for (int i = 1; i < 40; i++) {
      EEPROM.write(i,router_name_and_key[i]);
    }
    EEPROM.commit();

    // mark eeprom as forged
    forge_eeprom();
  }

  // eeprom read router_name
  for (int i = 1; i < 7; i++) {
    router_name[i-1] = EEPROM.read(i);
  }
  router_name[6]=0;

  radio.setCS(15);
  radio.initialize(FREQUENCY, MYNODEID, NETWORKID);
  radio.setHighPower();
}

// end setup
// --------------------------------
// main program

void loop() {

  if (millis() - keep_alive_timeout > 60000) {
    keep_alive_timeout = millis();
    void send_keep_alive();
  }

  if (digitalRead(BUTTON) == LOW) {
    captive_portal();
  }

  if (radio.receiveDone()) {

    Serial.print("received from node ");
    Serial.print(radio.SENDERID, DEC);
    Serial.print(", message [");
    char receivePayload[32]="";

    // The actual message is contained in the DATA array,
    // and is DATALEN bytes in size:

    int separator_count = 0;
    for (byte i = 0; i < radio.DATALEN; i++) {
      Serial.print((char)radio.DATA[i]);
      Serial.println("]");
      receivePayload[i] = radio.DATA[i];
      if (radio.DATA[i] == ':') separator_count ++;
    }
    if (separator_count == 5)  // Payload OK, processing
    {
      digitalWrite(LED, HIGH);
      int signal_strenght = (100+(((radio.RSSI)+28)*100/72));

      char serial[5] ="";
      char count[7]="";
      serial[0] = receivePayload[2];
      serial[1] = receivePayload[3];
      serial[2] = receivePayload[4];
      serial[3] = receivePayload[5];
      serial[4] = 0;
      count[0] = receivePayload[7];
      count[1] = receivePayload[8];
      count[2] = receivePayload[9];
      count[3] = receivePayload[10];
      count[4] = receivePayload[11];
      count[5] = receivePayload[12];
      count[6] = 0;

      // Send data to sink
      WiFiClient client;
      if (!client.connect(http_site, http_port) ) {
        blink_error();
      } else {
        client.print("GET /data_sink.php?data=");
        client.print(receivePayload);
        client.print(":");
        client.print(signal_strenght);
        client.print("&router=");
        client.print(router_name);
        client.println(" HTTP/1.1");
        client.print("Host: ");
        client.println(http_site);
        client.println("Connection: close");
        client.println();
      }

      // if count = 000000 get period and retrasmit it to that sensor
      // callback sintax is nnnn:c (n=nodeID;c=code_period)
      if (atoi(count) == 0) {
        client.connect(http_site, http_port);
        client.print("GET /get_period.php?serial=");
        client.print(serial);
        client.println(" HTTP/1.1");
        client.print("Host: ");
        client.println(http_site);
        client.println("Connection: close");
        client.println();

        unsigned long timeout = millis();
        while (client.available() == 0) {
          if (millis() - timeout > 5000) {
            client.stop();
            return;
          }
        }
        char period;
        // Read all the lines of the reply from server
        while(client.available()) {
          String line = client.readStringUntil('\r');
          period = line.charAt(1);
        }
        client.connect(http_site, http_port);
        client.print("GET /get_period.php?received=");
        client.print(period);
        client.println(" HTTP/1.1");
        client.print("Host: ");
        client.println(http_site);
        client.println("Connection: close");
        client.println();

        // Prepare outbuffer
        char outBuffer[7]= "";
        outBuffer[0]=serial[0];
        outBuffer[1]=serial[1];
        outBuffer[2]=serial[2];
        outBuffer[3]=serial[3];
        outBuffer[4]=':';
        outBuffer[5]=period;
        outBuffer[6]=0;

        radio.send(TONODEID, outBuffer, strlen(outBuffer));
      }
      digitalWrite(LED, LOW);
    }
  }
}

// --------------------------------

int check_eeprom_new(){
  int test1 = EEPROM.read(50);
  int test2 = EEPROM.read(51);
  int test3 = EEPROM.read(52);
  int test4 = EEPROM.read(53);

  // test numeri chiave presi a caso per eeprom vergine si/no
  if (test1 != 12 || test2 != 137 || test3 != 219 || test4 != 95){
    return 1;
  }
  else {
    return 0;
  }
}

// --------------------------------


void forge_eeprom(){
  // mark eeprom as forged
  EEPROM.write(50,0);
  EEPROM.write(51,0);
  EEPROM.write(52,0);
  EEPROM.write(53,0);
  EEPROM.commit();

  EEPROM.write(50,12);
  EEPROM.write(51,137);
  EEPROM.write(52,219);
  EEPROM.write(53,95);
  EEPROM.commit();
}

// --------------------------------

void send_keep_alive(){
  WiFiClient client;
  client.connect(http_site, http_port);
  client.print("GET /service_door.php?service=keep_alive&router=");
  client.print(router_name);
  client.println(" HTTP/1.1");
  client.print("Host: ");
  client.println(http_site);
  client.println("Connection: close");
  client.println();
}

// --------------------------------

void led_blink(){
  int m;
  for (m=0; m<6; m++)
  {
    digitalWrite(LED,HIGH);
    delay(80);
    digitalWrite(LED,LOW);
    delay(80);
  }
}

// --------------------------------

void blink_error(){
  int m;
  for (m=0; m<60; m++)
  {
    digitalWrite(LED,HIGH);
    delay(250);
    digitalWrite(LED,LOW);
    delay(250);
  }
}

// --------------------------------

void captive_portal() {
  delay(1000);
  digitalWrite(LED, HIGH);

  WiFiManager wifiManager;
  wifiManager.resetSettings();
  wifiManager.startConfigPortal("Hooly-router");
  digitalWrite(LED, LOW);
  ESP.restart();
}

// --------------------------------
